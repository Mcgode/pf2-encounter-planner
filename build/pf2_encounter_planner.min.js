!(function(e, t) {
"object" == typeof exports && "undefined" != typeof module
? t(exports)
: "function" == typeof define && define.amd
? define(["exports"], t)
: t((e.PF2EncounterPlanner = {}));
})(this, function(e) {
"use strict";
class t {
constructor(e = "Default") {
(this.name = e), (this.elements = []);
}
}
class n {
registerToSession(e) {
do {
this.id = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
} while (e.isIdUsed(this.id));
}
}
const r = {
TRIVIAL: "trivial",
LOW: "low",
MODERATE: "moderate",
SEVERE: "severe",
EXTREME: "extreme",
IMPOSSIBLE: "impossible"
},
s = {
"-4": 10,
"-3": 15,
"-2": 20,
"-1": 30,
0: 40,
1: 60,
2: 80,
3: 120,
4: 160
},
o = {trivial: 40, low: 60, moderate: 80, severe: 120, extreme: 160};
(e.Session = class {
constructor(e = "Default", t = {}) {
(this.name = e),
(this.params = Object.assign({autoLevelUp: !1}, t)),
(this.encounters = []);
}
addEncounter(e) {
let n = new t(e);
return this.encounters.push(n), n;
}
registerElement(e, t) {
let n = this.encounters.find(t => t.name === e);
return null != n && (n.elements.push(t), t.registerToSession(this)), null != n;
}
isIdUsed(e) {
for (let t of this.encounters)
for (let n of t.elements) if (n.id === e) return !0;
return !1;
}
}),
(e.Encounter = t),
(e.EncounterElement = n),
(e.FightElement = class extends n {
constructor() {
super(), (this.creatures = []);
}
getEncounterXpPerPlayer(e = 1, t = 4) {
let n = 0;
for (let t of this.creatures) {
let o = t.level - e;
if (o > 4) return r.IMPOSSIBLE;
o >= -4 && (n += t.amount * s[o.toString()]);
}
return (n *= t / 4), n;
}
getEncounterRating(e = 1, t = 4) {
let n = this.getEncounterXpPerPlayer(e, t),
s = 200,
i = null;
for (let e in o) s > o[e] && o[e] >= n && ((i = e), (s = o[e]));
return null == i ? r.IMPOSSIBLE : i;
}
}),
(e.Creature = class {
constructor(e, t, n, r = null) {
(this.name = e),
(this.level = null == t ? 0 : t),
(this.amount = null == n ? 1 : n),
(this.link = r);
}
}),
(e.EncounterRating = r),
Object.defineProperty(e, "__esModule", {value: !0});
});
